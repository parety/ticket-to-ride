#include <stdio.h>
#include <stdlib.h>
#include "interface.h"
#include "server.h"
#include "link.h"
#include "concat.h"

#define NB_PLAYERS 2
#define NB_STARTING_CARDS 5



int main(int argc,char * argv[]){
  //need 1 file
  if (argc != 2){
    printf("error : expected 1 argument, given %d\n",argc-1);
    return EXIT_FAILURE;
  }
  //initialisation of general informations
  struct Map_info map_info = get_map_info(argv[1]);
  struct Rail rails[map_info.nb_links];
  struct Objective all_objectives[map_info.nb_objs];
  struct Town towns[map_info.nb_towns];
  file2rails(rails, map_info.nb_rails, all_objectives, map_info.nb_objs, argv[1]);
  int * col = malloc(sizeof(int));
  int nb_colors = colors(rails,map_info.nb_links,col);




  //initialisation of server informations
  struct Link ** map = init_map(map_info.nb_towns, rails, map_info.nb_links); //matrix of link structures

  int ** card_hands = malloc(NB_PLAYERS*sizeof(int *));//array of the player's wagon card hands
  init_card_hands(NB_PLAYERS, NB_STARTING_CARDS, card_hands, col, nb_colors); //DONE

  int nb_cards[NB_PLAYERS];
  for (int i = 0; i < NB_PLAYERS){
    nb_cards[i] = NB_STARTING_CARDS;
  }



  int ** obj_hands = malloc(NB_PLAYERS*sizeof(int *));//array of the player's objective card hands
  init_obj_hands(NB_PLAYERS, NB_STARTING_OBJS, obj_hands, all_objectives, map_info.nb_objs);
  int nb_objs[NB_PLAYERS];
  init_nb_objs(NB_PLAYERS, NB_STARTING_OBJS, nb_objs);//array with nb_players cases which correspond to the nb of objs of each player


  
  //initialisation of player fonctions
  struct Player_fonctions * player_fonctions = malloc(NB_PLAYERS_MAX * sizeof(struct Player_fonctions));
  for (int i=0, i<NB_PLAYERS_MAX ; i++){
    player_fonctions[i].init_player = CONCAT(CONCAT(AI_ , i) , _init_player);
    player_fonctions[i].play_turn = CONCAT(CONCAT(AI_ , i) , _play_turn);
    player_fonctions[i].choose_objective = CONCAT(CONCAT(AI_ , i) , _choose_objective);
    player_fonctions[i].free_player = CONCAT(CONCAT(AI_ , i) , _free_player);
  }

  //initialisation of player informations
  for (int i=0; i<NB_PLAYERS ; i++){
    player_fonctions[i].init_player(i, NB_PLAYERS, map_info.nb_towns, map_info.nb_links, rails, map_info.nb_w_player, map_info.nb_objs, all_objectives);
  }
    
  //game start
  struct Action action;
  int wagons_remaining[NB_PLAYERS];
  init_wagons(wagons_remaining,NB_PLAYERS, map_info.nb_w_player);//DONE  
//array of the wagons remaining for each player
  int used_wagons[NB_PLAYERS];
  int  cards_in_hands[NB_PLAYERS];//array of the variation of the number of wagon cards in each hands (>=0 if draw, <= if built)
  int  objectives[NB_PLAYERS];//array of the number of objectives cards drawn during the last by each player
  int nb_new_rails = 0;
  struct New_rail changes[NB_PLAYERS];//array of the rails built during the last turn
  int new_obj[NB_PLAYERS][NB_OBJ_DRAWN_MAX];//array of the index of the objectives drawn by each player during the last turn
  int M_rail_length = max_rail_length(rails, map_info.nb_links);//max_rail_length DONE
  int cards[NB_PLAYERS][M_rail_length];  //array of the color of cards modified by each player during the last turn
  
  init_turn_informations(used_wagons, cards_in_hands, objectives, changes, new_obj, cards, NB_PLAYERS, NB_STARTING_CARDS, NB_OBJ_DRAWN_MAX, M_rail_length); // DONE  
//initialise all elts of used_wagons, objectives, new_obj, cards to 0 ; all elts of cards_in_hands to NB_STARTING_CARDS and all elts of changes to a New_rail "no_change" with rail=-1, player=-1.

  for ( int i =0 ; i<NB_PLAYERS ; i++){
    T_chosen_objs = player_fonctions[i].choose_objective(NB_STARTING_OBJS, obj_hands[i], MIN_OBJS_TO_PICK);
    if (are_objs_valid(T_chosen_objs, MIN_ONJS_TO_PICK, NB_STARTING_OBJS)){ //test if the number of chosen objectives are between MIN_OBJS_TO_PICK and NB_STARTING_OBJ   ////TO DO
      modify_objs(all_objectives, obj_hands[i], nb_objs[i], objectives[i]

    }
    


///TO FINISH GESTION DES OBJS


  }

  while ( ! is_last_turn(wagons_remaining,NB_PLAYERS)){//is_last_turn TO DO
      for (int j=0 ; j<NB_PLAYERS ; j++){
	action = player_fonctions[j].play_turn(used_wagons, cards_in_hand, objectives, nb_new_rails, changes, new_obj, cards);
	if (cheat(action,NB_PLAYERS,i,map_info.nb_objs,nb_objs,rails,map_info.nb_rails,wagons_remaining,card_hands,nb_cards,map,map_info.nb_town)) //pass turn if the client cheated TO DO
	  apply(action); //modify the server informations and the turn informations //TO DO
	///TO FINISH GESTION DES OBJS
      }
    }

  //game end
  //the winner is ...

  //free the memory
  free(player_fonctions);
  
  return EXIT_SUCCESS;
}
